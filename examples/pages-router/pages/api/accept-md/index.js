// Generated by accept-md. Do not edit the markdown block by hand.
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();

/** @param {import('next').NextApiRequest} req @param {import('next').NextApiResponse} res */
export default async function handler(req, res) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end();
  }
  const pathFromHeader = req.headers['x-accept-md-path'];
  const pathFromQuery = Array.isArray(req.query.path) ? req.query.path[0] : req.query.path;
  const pathRaw = (pathFromHeader || pathFromQuery) || '/';
  let path = typeof pathRaw === 'string' ? pathRaw : (pathRaw[0] || '/');
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return res.status(404).json({ error: 'Not found' });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably on Vercel: use host header with protocol, fall back to origin/referer, then VERCEL_URL, then localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    const host = req.headers.host;
    if (host) {
      const protocol = req.headers['x-forwarded-proto'] || (process.env.VERCEL_URL ? 'https' : 'http');
      baseUrl = protocol + '://' + host;
    } else {
      const originOrReferer = (req.headers.origin || req.headers.referer || '').replace(/\/?$/, '');
      if (originOrReferer) {
        baseUrl = originOrReferer;
      } else if (process.env.VERCEL_URL) {
        baseUrl = process.env.VERCEL_URL.startsWith('http') ? process.env.VERCEL_URL : 'https://' + process.env.VERCEL_URL;
      } else {
        baseUrl = 'http://localhost:' + (process.env.PORT || 3000);
      }
    }
  }
  // Convert req.headers to Headers for forwarding (e.g., for Vercel deployment protection)
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (value) {
      headers.set(key, Array.isArray(value) ? value[0] : value);
    }
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
    if (config.cache) {
      res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate');
    }
    res.status(200).send(markdown);
  } catch (err) {
    res.status(500).json({
      error: err instanceof Error ? err.message : 'Markdown generation failed',
    });
  }
}
