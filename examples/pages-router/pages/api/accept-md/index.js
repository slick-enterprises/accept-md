// Generated by accept-md. Do not edit the markdown block by hand.
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();

/** @param {import('next').NextApiRequest} req @param {import('next').NextApiResponse} res */
export default async function handler(req, res) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end();
  }
  const pathFromHeader = req.headers['x-accept-md-path'];
  const pathFromQuery = Array.isArray(req.query.path) ? req.query.path[0] : req.query.path;
  const pathRaw = (pathFromHeader || pathFromQuery) || '/';
  const path = typeof pathRaw === 'string' ? pathRaw : (pathRaw[0] || '/');
  const config = loadConfig(process.cwd());
  const baseUrl = config.baseUrl || (req.headers.origin || req.headers.referer || '').replace(/\/?$/, '') || ('http://localhost:' + (process.env.PORT || 3000));
  // Convert req.headers to Headers for forwarding (e.g., for Vercel deployment protection)
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (value) {
      headers.set(key, Array.isArray(value) ? value[0] : value);
    }
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
    if (config.cache) {
      res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate');
    }
    res.status(200).send(markdown);
  } catch (err) {
    res.status(500).json({
      error: err instanceof Error ? err.message : 'Markdown generation failed',
    });
  }
}
