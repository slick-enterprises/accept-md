// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from 'next/server';
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();
const HANDLER_PATH = '/api/accept-md';

export async function GET(request) {
  const pathFromHeader = request.headers.get('x-accept-md-path');
  const pathFromQuery = request.nextUrl.searchParams.get('path');
  const pathname = request.nextUrl.pathname;
  // Never use the handler path itself - always prefer header, then query, then pathname (if not handler), then default to '/'
  let path = pathFromHeader;
  if (!path || path.trim() === '') {
    path = pathFromQuery && pathFromQuery.trim() !== '' ? pathFromQuery : null;
  }
  // If pathname starts with /api/accept-md, extract the original path from it
  // This handles next.config rewrites that use /api/accept-md/:path* pattern
  if (!path && pathname.startsWith(HANDLER_PATH + '/')) {
    path = pathname.slice(HANDLER_PATH.length);
    // Handle root path case: /api/accept-md/ becomes /
    if (path === '') {
      path = '/';
    }
  }
  if (!path) {
    path = pathname !== HANDLER_PATH ? pathname : null;
  }
  if (!path || path === HANDLER_PATH) {
    path = '/';
  }
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably: prefer config, then use request origin, fall back to localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    baseUrl = request.nextUrl.origin || 'http://localhost:' + (process.env.PORT || 3000);
  }
  // Forward headers but avoid sending markdown Accept header to the upstream page fetch
  const headers = new Headers(request.headers);
  headers.delete('accept');
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    return new NextResponse(markdown, {
      headers: {
        'Content-Type': 'text/markdown; charset=utf-8',
        'Cache-Control': config.cache ? 'public, s-maxage=60, stale-while-revalidate' : 'no-store',
      },
    });
  } catch (err) {
    return NextResponse.json(
      { error: err instanceof Error ? err.message : 'Markdown generation failed' },
      { status: 500 }
    );
  }
}
