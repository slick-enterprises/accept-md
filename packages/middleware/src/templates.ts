/**
 * Generated middleware and route handler templates.
 */

export const MIDDLEWARE_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from 'next/server';

const MARKDOWN_ACCEPT = new RegExp('\\\\btext/markdown\\\\b', 'i');
const EXCLUDED_PREFIXES = ['/api/', '/_next/'];
const MARKDOWN_HANDLER_PATH = '/api/accept-md';

/** @param {import('next/server').NextRequest} request */
export function middleware(request) {
  const pathname = request.nextUrl.pathname;
  const accept = (request.headers.get('accept') || '').toLowerCase();
  if (!MARKDOWN_ACCEPT.test(accept)) return NextResponse.next();
  if (EXCLUDED_PREFIXES.some((p) => pathname.startsWith(p))) return NextResponse.next();

  const url = request.nextUrl.clone();
  url.pathname = MARKDOWN_HANDLER_PATH;
  url.searchParams.set('path', pathname);
  // Let Vercel/Next.js forward all original request metadata (auth, cookies, protection)
  // and only use the query parameter to communicate the original pathname.
  return NextResponse.rewrite(url);
}
`;

export const APP_ROUTE_HANDLER_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from 'next/server';
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();
const HANDLER_PATH = '/api/accept-md';

/** @param {import('next/server').NextRequest} request */
export async function GET(request) {
  const pathFromHeader = request.headers.get('x-accept-md-path');
  const pathFromQuery = request.nextUrl.searchParams.get('path');
  const pathname = request.nextUrl.pathname;
  // Never use the handler path itself - always prefer header, then query, then pathname (if not handler), then default to '/'
  let path = pathFromHeader;
  if (!path || path.trim() === '') {
    path = pathFromQuery && pathFromQuery.trim() !== '' ? pathFromQuery : null;
  }
  // If pathname starts with /api/accept-md, extract the original path from it
  // This handles next.config rewrites that use /api/accept-md/:path* pattern
  if (!path && pathname.startsWith(HANDLER_PATH + '/')) {
    path = pathname.slice(HANDLER_PATH.length);
    // Handle root path case: /api/accept-md/ becomes /
    if (path === '') {
      path = '/';
    }
  }
  if (!path) {
    path = pathname !== HANDLER_PATH ? pathname : null;
  }
  if (!path || path === HANDLER_PATH) {
    path = '/';
  }
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably: prefer config, then use request origin, fall back to localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    baseUrl = request.nextUrl.origin || 'http://localhost:' + (process.env.PORT || 3000);
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers: request.headers,
    });
    return new NextResponse(markdown, {
      headers: {
        'Content-Type': 'text/markdown; charset=utf-8',
        'Cache-Control': config.cache ? 'public, s-maxage=60, stale-while-revalidate' : 'no-store',
      },
    });
  } catch (err) {
    return NextResponse.json(
      { error: err instanceof Error ? err.message : 'Markdown generation failed' },
      { status: 500 }
    );
  }
}
`;

export const PAGES_API_HANDLER_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();

/** @param {import('next').NextApiRequest} req @param {import('next').NextApiResponse} res */
export default async function handler(req, res) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end();
  }
  const pathFromHeader = req.headers['x-accept-md-path'];
  const pathFromQuery = Array.isArray(req.query.path) ? req.query.path[0] : req.query.path;
  const pathRaw = (pathFromHeader || pathFromQuery) || '/';
  const path = typeof pathRaw === 'string' ? pathRaw : (pathRaw[0] || '/');
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably on Vercel: use host header with protocol, fall back to origin/referer, then VERCEL_URL, then localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    const host = req.headers.host;
    if (host) {
      const protocol = req.headers['x-forwarded-proto'] || (process.env.VERCEL_URL ? 'https' : 'http');
      baseUrl = protocol + '://' + host;
    } else {
      const originOrReferer = (req.headers.origin || req.headers.referer || '').replace(/\\\\/?$/, '');
      if (originOrReferer) {
        baseUrl = originOrReferer;
      } else if (process.env.VERCEL_URL) {
        baseUrl = process.env.VERCEL_URL.startsWith('http') ? process.env.VERCEL_URL : 'https://' + process.env.VERCEL_URL;
      } else {
        baseUrl = 'http://localhost:' + (process.env.PORT || 3000);
      }
    }
  }
  // Convert req.headers to Headers for forwarding (e.g., for Vercel deployment protection)
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (value) {
      headers.set(key, Array.isArray(value) ? value[0] : value);
    }
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
    if (config.cache) {
      res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate');
    }
    res.status(200).send(markdown);
  } catch (err) {
    res.status(500).json({
      error: err instanceof Error ? err.message : 'Markdown generation failed',
    });
  }
}
`;

/**
 * Returns the rewrite configuration object for next.config.js/ts
 * This is the preferred method over middleware (Next.js is moving away from middleware).
 */
export function getNextConfigRewrite() {
  return {
    source: '/:path*',
    destination: '/api/accept-md/:path*',
    has: [
      {
        type: 'header',
        key: 'accept',
        value: '(.*)text/markdown(.*)',
      },
    ],
  };
}
