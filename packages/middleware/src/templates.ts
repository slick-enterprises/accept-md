/**
 * Generated middleware and route handler templates.
 */

export const MIDDLEWARE_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from 'next/server';

const MARKDOWN_ACCEPT = new RegExp('\\\\btext/markdown\\\\b', 'i');
const EXCLUDED_PREFIXES = ['/api/', '/_next/'];
const MARKDOWN_HANDLER_PATH = '/api/accept-md';

/** @param {import('next/server').NextRequest} request */
export function middleware(request) {
  const pathname = request.nextUrl.pathname;
  const accept = (request.headers.get('accept') || '').toLowerCase();
  if (!MARKDOWN_ACCEPT.test(accept)) return NextResponse.next();
  if (EXCLUDED_PREFIXES.some((p) => pathname.startsWith(p))) return NextResponse.next();

  const url = request.nextUrl.clone();
  url.pathname = MARKDOWN_HANDLER_PATH;
  url.searchParams.set('path', pathname);
  // Let Vercel/Next.js forward all original request metadata (auth, cookies, protection)
  // and only use the query parameter to communicate the original pathname.
  return NextResponse.rewrite(url);
}
`;

export const APP_ROUTE_HANDLER_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { NextResponse } from 'next/server';
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();
const HANDLER_PATH = '/api/accept-md';

/** @param {import('next/server').NextRequest} request */
export async function GET(request) {
  const pathFromHeader = request.headers.get('x-accept-md-path');
  const pathFromQuery = request.nextUrl.searchParams.get('path');
  // Headers that may carry the original matched path when using rewrites on Vercel/Next.js
  const pathFromMatchedHeader =
    request.headers.get('x-matched-path') ||
    request.headers.get('x-vercel-original-path') ||
    request.headers.get('x-original-path') ||
    request.headers.get('x-rewrite-path');
  const pathname = request.nextUrl.pathname;
  // Never use the handler path itself - always prefer, in order:
  // 1) explicit header, 2) internal matched-path header, 3) query param, 4) pathname (if not handler), then default to '/'
  let path = pathFromHeader && pathFromHeader.trim() !== '' ? pathFromHeader : null;
  if (!path && pathFromMatchedHeader && pathFromMatchedHeader.trim() !== '') {
    path = pathFromMatchedHeader;
  }
  if (!path && pathFromQuery && pathFromQuery.trim() !== '') {
    path = pathFromQuery;
  }
  // If pathname starts with /api/accept-md, extract the original path from it
  // This handles next.config rewrites that use /api/accept-md/:path* pattern
  if (!path && pathname.startsWith(HANDLER_PATH + '/')) {
    path = pathname.slice(HANDLER_PATH.length);
    // Handle root path case: /api/accept-md/ becomes /
    if (path === '') {
      path = '/';
    }
  }
  if (!path) {
    path = pathname !== HANDLER_PATH ? pathname : null;
  }
  if (!path || path === HANDLER_PATH) {
    path = '/';
  }
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably: prefer config, then use request origin, fall back to localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    baseUrl = request.nextUrl.origin || 'http://localhost:' + (process.env.PORT || 3000);
  }
  // Forward headers but avoid sending markdown Accept header to the upstream page fetch
  const headers = new Headers(request.headers);
  headers.delete('accept');
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    return new NextResponse(markdown, {
      headers: {
        'Content-Type': 'text/markdown; charset=utf-8',
        'Cache-Control': config.cache ? 'public, s-maxage=60, stale-while-revalidate' : 'no-store',
      },
    });
  } catch (err) {
    return NextResponse.json(
      { error: err instanceof Error ? err.message : 'Markdown generation failed' },
      { status: 500 }
    );
  }
}
`;

export const PAGES_API_HANDLER_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();

/** @param {import('next').NextApiRequest} req @param {import('next').NextApiResponse} res */
export default async function handler(req, res) {
  if (req.method !== 'GET') {
    res.setHeader('Allow', 'GET');
    return res.status(405).end();
  }
  const pathFromHeader = req.headers['x-accept-md-path'];
  const pathFromQuery = Array.isArray(req.query.path) ? req.query.path[0] : req.query.path;
  const pathFromMatchedHeader =
    req.headers['x-matched-path'] ||
    req.headers['x-vercel-original-path'] ||
    req.headers['x-original-path'] ||
    req.headers['x-rewrite-path'];
  // Determine raw path in priority order: header, internal matched-path header, query, then fallback
  let pathRaw = pathFromHeader || pathFromMatchedHeader || pathFromQuery || '/';
  // Handle placeholder values like ":path*" that can appear from Next.js rewrite configs
  let path;
  if (typeof pathRaw === 'string') {
    path = (pathRaw === '' || pathRaw.includes(':path')) ? '/' : pathRaw;
  } else {
    path = pathRaw[0] || '/';
  }
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return res.status(404).json({ error: 'Not found' });
  }
  const config = loadConfig(process.cwd());
  // Construct baseUrl reliably on Vercel: use host header with protocol, fall back to origin/referer, then VERCEL_URL, then localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    const host = req.headers.host;
    if (host) {
      const protocol = req.headers['x-forwarded-proto'] || (process.env.VERCEL_URL ? 'https' : 'http');
      baseUrl = protocol + '://' + host;
    } else {
      const originOrReferer = (req.headers.origin || req.headers.referer || '').replace(/\\\\/?$/, '');
      if (originOrReferer) {
        baseUrl = originOrReferer;
      } else if (process.env.VERCEL_URL) {
        baseUrl = process.env.VERCEL_URL.startsWith('http') ? process.env.VERCEL_URL : 'https://' + process.env.VERCEL_URL;
      } else {
        baseUrl = 'http://localhost:' + (process.env.PORT || 3000);
      }
    }
  }
  // Convert req.headers to Headers for forwarding (e.g., for Vercel deployment protection)
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (!value) continue;
    // Do not forward markdown Accept header to the upstream page fetch
    if (key.toLowerCase() === 'accept') continue;
    headers.set(key, Array.isArray(value) ? value[0] : value);
  }
  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    res.setHeader('Content-Type', 'text/markdown; charset=utf-8');
    if (config.cache) {
      res.setHeader('Cache-Control', 'public, s-maxage=60, stale-while-revalidate');
    }
    res.status(200).send(markdown);
  } catch (err) {
    res.status(500).json({
      error: err instanceof Error ? err.message : 'Markdown generation failed',
    });
  }
}
`;

export const SVELTEKIT_ROUTE_HANDLER_TEMPLATE = `// Generated by accept-md. Do not edit the markdown block by hand.
import { getMarkdownForPath, loadConfig } from 'accept-md-runtime';

const cache = new Map();
const HANDLER_PATH = '/api/accept-md';

export async function GET(event) {
  const url = event.url;
  const request = event.request;

  const pathFromHeader = request.headers.get('x-accept-md-path');
  const pathFromQuery = url.searchParams.get('path');
  const pathname = url.pathname;

  // Determine raw path in priority order:
  // 1) explicit header
  // 2) query parameter
  // 3) path suffix after /api/accept-md (for /api/accept-md/[...path] routes)
  let path = pathFromHeader && pathFromHeader.trim() !== '' ? pathFromHeader : null;
  if (!path && pathFromQuery && pathFromQuery.trim() !== '') {
    path = pathFromQuery;
  }
  if (!path && pathname.startsWith(HANDLER_PATH + '/')) {
    path = pathname.slice(HANDLER_PATH.length);
    if (path === '') {
      path = '/';
    }
  }
  if (!path || path === HANDLER_PATH) {
    path = '/';
  }
  // Ensure path starts with /
  if (!path.startsWith('/')) {
    path = '/' + path;
  }
  // Exclude /api and /_next paths - return 404 for these (keeps behavior aligned with Next.js)
  if (path.startsWith('/api/') || path.startsWith('/_next/')) {
    return new Response(JSON.stringify({ error: 'Not found' }), {
      status: 404,
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
      },
    });
  }

  const config = loadConfig(process.cwd());

  // Construct baseUrl: prefer config, then use request origin, fall back to localhost
  let baseUrl = config.baseUrl;
  if (!baseUrl) {
    baseUrl = url.origin || 'http://localhost:' + (process.env.PORT || 5173);
  }

  // Forward headers but avoid sending markdown Accept header to the upstream page fetch
  const headers = new Headers(request.headers);
  headers.delete('accept');

  try {
    const markdown = await getMarkdownForPath({
      pathname: path,
      baseUrl,
      config,
      cache: config.cache !== false ? cache : undefined,
      headers,
    });
    return new Response(markdown, {
      headers: {
        'Content-Type': 'text/markdown; charset=utf-8',
        'Cache-Control': config.cache ? 'public, s-maxage=60, stale-while-revalidate' : 'no-store',
      },
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : 'Markdown generation failed';
    return new Response(JSON.stringify({ error: message }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json; charset=utf-8',
      },
    });
  }
}
`;

/**
 * Returns the rewrite configuration object for next.config.js/ts
 * This is the preferred method over middleware (Next.js is moving away from middleware).
 */
export function getNextConfigRewrite() {
  return {
    source: '/:path*',
    destination: '/api/accept-md/:path*',
    has: [
      {
        type: 'header',
        key: 'accept',
        value: '(.*)text/markdown(.*)',
      },
    ],
  };
}
